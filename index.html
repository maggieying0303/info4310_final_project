<!DOCTYPE html>
<html lang = "en">
<head>
  <meta charset="UTF-8" />
  <link rel="shortcut icon" href="#"/>
  <script src="https://d3js.org/d3.v5.min.js"></script>
  <script src="https://d3js.org/topojson.v2.min.js"></script>
  <link rel="preconnect" href="https://fonts.gstatic.com">
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@500;600&display=swap" rel="stylesheet">
  <link rel="stylesheet" type="text/css" href="css/all.css" media="all" />

  <title>Final Project</title>
</head>

<body>

  <!-- <h1></h1> -->


  <img src="pics/mock1.png" style="width: 700px" alt="mock"/>
  <img src="pics/mock2.png" style="width: 700px" alt="mock"/>
  <br/>
  <br/>
  <br/>
  <br/>
  <br/>
  <h2 style="text-align: center">average movie ratings across platforms</h2>
  <div style="text-align: center"id="yolk" width="700" height="700"></div>
  <svg width=800 height=600 id="bar_chart"></svg>
  <div id="disney" style="width: 500px; height: 500px;"></div>
  <div id="hulu" style="width: 500px; height: 500px;"></div>
  <div id="netflix" style="width: 500px; height: 500px;"></div>
  <div id="prime" style="width: 500px; height: 500px;"></div>
  <svg width=800 height=600 id="genreChart" ></svg>

  <script>

  const requestData = async function() {

    //reading data
    const movies = await d3.csv("datasets/movies.csv");

    const movies_netflix = await d3.csv("datasets/movies_netflix.csv");
    // console.log(movies_netflix);

    const movies_hulu = await d3.csv("datasets/movies_hulu.csv");
    // console.log(movies_hulu);

    const movies_prime = await d3.csv("datasets/movies_prime.csv");
    // console.log(movies_prime);

    const movies_disney = await d3.csv("datasets/movies_disney.csv");
    // console.log(movies_disney);

    const top20_genres = await d3.csv("datasets/top20_genres.csv");


    const yolk = await d3.csv("datasets/genre_ratings.csv");

    // console.log(yolk);

    let w = 600;				//Width of the circle
    let h = 600;				//Height of the circle
    let margin = {top: 40, right: 40, bottom: 40, left: 40}; //The margins of the SVG
    let levels = 4;				//How many levels or inner circles should there be drawn
    let maxValue = 7; 			//What is the value that the biggest circle will represent
    let labelFactor = 1.25; 	//How much farther than the radius of the outer circle should the labels be placed
    let wrapWidth = 60; 		//The number of pixels after which a label needs to be given a new line
    let opacityArea = 0.15; 	//The opacity of the area of the blob
    let dotRadius = 4; 			//The size of the colored circles of each blog
    let opacityCircles = 0.1; 	//The opacity of the circles of each blob
    let strokeWidth = 3; 		//The width of the stroke around each blob
    let roundStrokes = false;	//If true the area and stroke will follow a round path (cardinal-closed)
    var color = d3.scaleOrdinal().domain(['Disney+', 'Hulu', 'Netflix', 'Prime Video']).range(['#9e9e9e','#60EEA8','#ED535B','#4DC2EA' ]);
    // let color = d3.scaleOrdinal(d3.schemeCategory10);
    let axes = ['Drama','Comedy', 'Thriller', 'Action', 'Documentary', 'Family', 'Adventure', 'Fantasy'];

    // getting data into the right format

    data = []

      yolk.forEach((d, i) => {

        let list = []

        for(key in d){
          let dict = {};
          dict['axis'] = key;
          dict['ratings'] = Math.round(d[key] * 100) / 100;
          list.push(dict);
        }

        list.shift();
        data.push(list);

      });

      // console.log(data);


    var allAxis = (axes),	//Names of each axis
          total = allAxis.length,					//The number of different axes
          radius = Math.min((w-margin.left-margin.right)/2, (h-margin.top-margin.bottom)/2), 	//Radius of the outermost circle
          angleSlice = Math.PI * 2 / total;		//The width in radians of each "slice"

    // translate rating values to radius
    var rScale = d3.scaleLinear().domain([5, 7]).range([0, radius]);

    //Initiate the radar chart SVG
    var svg = d3.select("#yolk").append("svg")
                .attr("width",  w + margin.left + margin.right)
                .attr("height", h + margin.top + margin.bottom)
                .attr("class", "radar"+"#yolk");

    //Append a g element
    var g = svg.append("g")
               .attr("transform", "translate(" + (w/2 + margin.left) + "," + (h/2 + margin.top) + ")");

    var axisGrid = g.append("g").attr("class", "axisWrapper");

    //Draw the background circles
    axisGrid.selectAll(".levels")
            .data(d3.range(1,levels+1).reverse())
            .enter()
            .append("circle")
            .attr("class", "gridCircle")
            .attr("r", d => radius/levels*d)
            .style("fill", "#e5e5e5")
            .style("stroke", "#CDCDCD")
            .style("fill-opacity", opacityCircles);

    //Text indicating at what rating each level is
    axisGrid.selectAll(".axisLabel")
             .data(d3.range(1,(levels+1)).reverse())
             .enter()
             .append("text")
             .attr("class", "axisLabel")
             .attr("x", 4)
             .attr("y", d => -d*radius/levels)
             .attr("dy", "0.4em")
             .style("font-size", "14px")
             .attr("fill", "#737373")
             .text(d => maxValue + d/2 - 2);

    //Create the straight lines radiating outward from the center
    var axis = axisGrid.selectAll(".axis")
                       .data(allAxis)
                       .enter()
                       .append("g")
                       .attr("class", "axis");

    //Append the lines
    axis.append("line")
        .attr("x1", 0)
        .attr("y1", 0)
        .attr("x2", (d, i) => rScale(maxValue) * Math.cos(angleSlice*i - Math.PI/2))
        .attr("y2", (d, i) => rScale(maxValue) * Math.sin(angleSlice*i - Math.PI/2))
        .attr("class", "line")
        .style("stroke", "white")
        .style("stroke-width", "2px");

    //Append the labels at each axis
    axis.append("text")
        .attr("class", "legend")
        .style("font-size", "12px")
        .style("font-weight", "bold")
        .attr("text-anchor", "middle")
        .attr("dy", "0.35em")
        .attr("x", (d, i) => rScale(maxValue * 1.05) * Math.cos(angleSlice*i - Math.PI/2))
        .attr("y", (d, i) => rScale(maxValue * 1.05) * Math.sin(angleSlice*i - Math.PI/2))
        .text(d => d)
        .call(wrap, wrapWidth);

    //The radial line function
    var radarLine = d3.lineRadial()
                      .radius(d => rScale(d.ratings))
                      .angle((d,i) => i*angleSlice)
                      .curve(d3.curveCardinalClosed);

    // if(roundStrokes) {
    //   radarLine.curve(d3.curveCardinalClosed);
    // }

    // Create a wrapper for the blobs
    var blobWrapper = g.selectAll(".radarWrapper")
                       .data(data)
                       .enter()
                       .append("g")
                       .attr("class", "radarWrapper");

    blobWrapper.append("path")
              .attr("class", "radarArea")
              .attr("d", d => radarLine(d) )
              .style("fill", (d,i) => color(i))
              .style("fill-opacity", opacityArea)
              .on('mouseover', function (d,i){
                  //Dim all blobs
                  d3.selectAll(".radarArea")
                    .transition().duration(200)
                    .style("fill-opacity", 0.1);

                  //dim the outlines as well
                  d3.selectAll(".radarStroke")
                    .transition().duration(200)
                    .style("opacity", 0.2);
                  //Bring back the hovered over blob
                  d3.select(this)
                    .transition().duration(200)
                    .style("fill-opacity", 0.7);
                })
                .on('mouseout', function(){
                  //Bring back all blobs
                  d3.selectAll(".radarArea")
                    .transition().duration(200)
                    .style("fill-opacity", opacityArea);

                  //bring back stroke-width
                  d3.selectAll(".radarStroke")
                    .transition().duration(200)
                    .style("opacity", 1);
               });

    //Create the outlines
    blobWrapper.append("path")
               .attr("class", "radarStroke")
               .attr("d", (d,i) => radarLine(d))
               .style("stroke-width", strokeWidth + "px")
               .style("stroke", (d,i) => color(i))
               .style("fill", "none");

    //Append the circles
    blobWrapper.selectAll(".radarCircle")
               .data( d => d)
               .enter().append("circle")
               .attr("class", "radarCircle")
               .attr("r", dotRadius)
               .attr("cx", (d,i) => rScale(d.ratings) * Math.cos(angleSlice*i - Math.PI/2))
               .attr("cy", (d,i) => rScale(d.ratings) * Math.sin(angleSlice*i - Math.PI/2))
               .style("fill", (d,i,j) => color(j))
               .style("fill-opacity", 0.8);

    //hovering interaction
    var blobCircleWrapper = g.selectAll(".radarCircleWrapper")
                             .data(data)
                             .enter().append("g")
                             .attr("class", "radarCircleWrapper");

    //Append a set of invisible circles on top for the mouseover pop-up
    blobCircleWrapper.selectAll(".radarInvisibleCircle")
                     .data((d,i) => d)
                    .enter().append("circle")
                    .attr("class", "radarInvisibleCircle")
                    .attr("r", dotRadius*1.5)
                    .attr("cx", (d,i) => rScale(d.ratings) * Math.cos(angleSlice*i - Math.PI/2))
                    .attr("cy", (d,i) => rScale(d.ratings) * Math.sin(angleSlice*i - Math.PI/2))
                    .style("fill", "none")
                    .style("pointer-events", "all")
                    .on("mouseover", function(d,i) {
                      newX =  parseFloat(d3.select(this).attr('cx')) - 10;
                      newY =  parseFloat(d3.select(this).attr('cy')) - 10;

                      tooltip.attr('x', newX)
                             .attr('y', newY)
                             .text(d.ratings)
                             .transition().duration(200)
                             .style('opacity', 1);
                    })
                    .on("mouseout", function(){
                      tooltip.transition().duration(200)
                             .style("opacity", 0);
                    });


        var tooltip = g.append("text")
                       .attr("class", "tooltip")
                       .style("opacity", 0);


    // helper function
    function wrap(text, width){

      text.each(function(){

        var text = d3.select(this),
              words = text.text().split(/\s+/).reverse(),
              word,
              line = [],
              lineNumber = 0,
              lineHeight = 1.4, // ems
              y = text.attr("y"),
              x = text.attr("x"),
              dy = parseFloat(text.attr("dy")),
              tspan = text.text(null).append("tspan").attr("x", x).attr("y", y).attr("dy", dy + "em");

        while (word = words.pop()) {
              line.push(word);
              tspan.text(line.join(" "));
              if (tspan.node().getComputedTextLength() > width) {
              line.pop();
              tspan.text(line.join(" "));
              line = [word];
              tspan = text.append("tspan").attr("x", x).attr("y", y).attr("dy", ++lineNumber * lineHeight + dy + "em").text(word);
              }
            }

      });


    // density charts
    const dict = {'Disney+':{'order':4, 'dataset':movies_disney, 'color':'#000000','id':'#disney'},
    'Hulu':{'order':2, 'dataset':movies_hulu, 'color':'#1CE783','id':'#hulu'},
    'Netflix':{'order':1, 'dataset':movies_netflix, 'color':'#E50914', 'id':'#netflix'},
    'Prime Video':{'order':3, 'dataset':movies_prime,'color':'#00A8E1','id':'#prime'},
    };

    for (platform in dict){

      const container = d3.select(dict[platform]['id']).style("position","relative");
      const width = Number(container.style("width").replace("px",""));
      const height = Number(container.style("height").replace("px",""));
      const margin = { top: 10, right: 10, bottom: 50, left:50};
      const chartWidth = width - margin.left - margin.right;
      const chartHeight = height - margin.top - margin.bottom;

      // Add a canvas element
      const canvas = container.append("canvas")
                              .attr("width",chartWidth)
                              .attr("height",chartHeight)
                              .style("position","absolute")
                              .style("top",margin.top + 'px')
                              .style("left",margin.left + 'px');

      // Layer SVG on top of the canvas so we can draw axes and make the canvas interactive
      const svg = container.append("svg")
                           .attr("width", width)
                           .attr("height", height)
                           .style("position","absolute")
                           .style("top", 0)
                           .style("left", 0);
                           const interactiveArea = svg.append("g").attr("transform","translate("+margin.left+","+margin.top+")");

     interactiveArea.append("rect")
                    .attr("width",chartWidth)
                    .attr("height",chartHeight)
                    .attr("x",0)
                    .attr("y",0)
                    .attr("opacity",0);

      indexMatrix = []
      for (let i=0; i<height; i++) {
        row = [];
        for (let j=0; j<width; j++) {
          row.push(-1);
        }
        indexMatrix.push(row);
      }

      // draw
      const context = canvas.node().getContext('2d');
      context.clearRect(0, 0, width, height);
      context.globalAlpha = 0.6;

      // console.log(dict[platform]['dataset']);

      dict[platform]['dataset'].forEach( (d,i) => {
        let x = d3.randomNormal(margin.left, chartWidth)();
        let y = d3.randomNormal(margin.top, chartHeight)();
        let rad = 3;
        let color = "purple";

        context.fillStyle = color;
        context.beginPath();
        context.arc(x, y, rad, 0, 2*Math.PI);
        context.fill();

      // Store the indices to make the canvas interactive
      // let radSq = rad * rad;
      // for (let mx=x-rad; mx<=x+rad; mx++) {
      //   for (let my=y-rad; my<=y+rad; my++) {
      //     distance = ((x - mx) * (x - mx)) + ((y - my) * (y - my));
      //     console.log(distance);
      //     if (distance <= radSq) {
      //         indexMatrix[parseInt(my)][parseInt(mx)] = i;
      //     }
      //  }
      // }

    });

    console.log(dict[platform]['dataset']);

  }

  // const genreSVG = d3.select("svg#genreChart");
  // let genreMargin = { top: 10, right: 10, bottom: 50, left:50};
  // let genreWidth = genreSVG.attr("width") - genreMargin.left - genreMargin.right;
  // // console.log(genreWidth)
  // let genreHeight = genreSVG.attr("height") - genreMargin.top - genreMargin.bottom;
  // // console.log(genreHeight)
  //
  // let annotations = genreSVG.append("g").attr("id","annotations");
  // let chartArea = genreSVG.append("g").attr("id","points")
  //                 .attr("transform","translate("+genreMargin.left+","+genreMargin.top+")");
  //
  // disneyTotal = movies_disney.length;
  // netflixTotal = movies_netflix.length;
  // huluTotal = movies_hulu.length;
  // primeTotal = movies_prime.length;
  //
  // let providerList = ["Netflix", "Hulu", "Disney+", "Prime"]
  // let totalList = [disneyTotal, netflixTotal, huluTotal, primeTotal];
  //
  // let maxMovies = d3.max(totalList);
  //
  // let top5_genres = top20_genres.slice(0, 5);
  // // console.log(top5_genres[0]["Genre"]);
  //
  // let genreTitles = [];
  // for (i in top5_genres) {
  //   genreTitles.push(top5_genres[i]["Genre"]);
  // }
  // console.log(genreTitles);

  // Scales
  // const providerScale = d3.scaleBand()
  //                         .domain(providerList)
  //                         .range([0, genreWidth]);
  //
  // const genreScaleCategories = d3.scaleBand()
  //                      .domain(genreTitles)
  //                      .range([genreHeight, 0])
  //
  // const genreScale = d3.scaleLinear()
  //                      .domain([0, maxMovies])
  //                      .range([genreHeight, 0])

  // Axes
  // x axis
  // genreSVG.append("g")
  //         .attr("class", "x")
  //         .attr("transform","translate("+(genreMargin.left+50)+","+(genreHeight+genreMargin.top)+")")
  //         .call(d3.axisBottom(providerScale)
  //                 .tickSize(0))
  //         .selectAll("text")
  //         .attr("transform","translate("+0+","+genreMargin.top+")")
  //         .style("font-size", 14)

  // y axis
  // genreSVG.append("g")
  //         .attr("class", "y")
  //         .attr("transform","translate("+(genreMargin.left+50)+","+(genreMargin.top)+")")
  //         .call(d3.axisLeft(genreScaleCategories)
  //                 .tickSize(0))
  //         .selectAll("text")
  //         .attr("transform","translate("+(-genreMargin.right)+","+0+")")
  //         .style("font-size", 14)

  // color palette = one color per subgroup
  // const colorScale = d3.scaleOrdinal()
  //                      .domain(providerList)
  //                      .range(['#e50914','#3DBB3D','#113CCF','#00A8E1'])

  // Netflix movies
  // let netflix_genrecount = {}
  // for (i in movies_netflix) {
  //   console.log((movies_netflix[i]["Genres"]).split(","));
  // }


  //barchart!!!

  let allLayer = d3.select("#bar_chart").append("g");
  let allWidth = d3.select("#bar_chart").attr("width");
  let allHeight = d3.select("#bar_chart").attr("height");
  const scale_barchart = d3.scaleLinear().domain([0, movies_prime.length]).range([10, allWidth-10]);

      const dict_bar = {'Netflix':{'order':1, 'dataset':movies_netflix, 'color':'#E50914'}, 'Hulu':{'order':2, 'dataset':movies_hulu, 'color':'#1CE783'}, 'Prime Video':{'order':3, 'dataset':movies_prime, 'color':'#00A8E1'}, 'Disney+':{'order':4, 'dataset':movies_disney, 'color':'#000000'}}

      for (platform in dict_bar){

        d3.select("#bar_chart")
          .append("rect")
          .attr("x", 0)
          .attr("y", (allHeight-100)/4*dict_bar[platform]['order'])
          .attr("width", scale_barchart(dict_bar[platform]['dataset'].length))
          .attr("height", 20)
          .attr("fill", dict_bar[platform]['color'])
          .attr("opacity", 0.7);

        d3.select("#bar_chart")
          .append("text")
          .text(platform+": "+dict_bar[platform]['dataset'].length.toString())
          .attr("x", 0)
          .attr("y", (allHeight-100)/4*dict_bar[platform]['order']+40);

      }

  }
}
  requestData();

  </script>

</body>
</html>
